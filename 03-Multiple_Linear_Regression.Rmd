# Multiple Linear Regression

So far, we have dealt with the simple mean model and the model with one predictor
in the Bayesian and Frequentist framework.
We will now add another predictor and subsequently an interaction term to the model.
Finally, we will add more than two predictors to the model.

If you feel confused at any point: As Richard McElreath repeatedly says:
This is normal, it means you are paying attention. I also refer to the
great [Richard Feynman](https://www.youtube.com/watch?v=lytxafTXg6c&ab_channel=sdfhsfh).

## Linear Regression with 2 predictors in the Bayesian Framework

### Meaning of "linear"
What is a linear model? The term "linear" refers to the relationship of the predictors 
with the dependent variable (or outcome). The following model is also linear:

$$height_i = \beta_0 + \beta_1 x_i + \beta_2 x_i^2$$

The model is linear in the parameters $\beta_0, \beta_1, \beta_2$ but not in the predictors $x_i$.
The term $x_i^2$ is ok, since the heights are just sums of multiples of the predictors (which can be nonlinear).
This model is not a linear model anymore:

$$height_i = \beta_0 + \beta_1 x_i + e^{\beta_2 x_i^2}$$

$\beta_2$ is now is the exponent of $e$. It would also not be linear,
if the coefficients are in a square root or in the denominator of a fraction,
or in a sine or in a logarithm. You get the idea.

Here is an easy way to check if the model is linear: If I change the predictor-value 
(i.e.,the value of $x_i$, $x_i^2$ or whatever your predictor is) by one unit,
the change in the (expected value of the) dependent variable is the coefficient in front of 
the predictor ($\beta_i$).

### Adding a transformed predictor to the model {#adding_transformed_predictor}

Around 4.5. in the book [Statistical Rethinking](https://civil.colorado.edu/~balajir/CVEN6833/bayes-resources/RM-StatRethink-Bayes.pdf)
there is are lineare regression using a quadratic term for weight. 
It is a principle, called the "**variable inclusion principle**", that we always include the lower order terms when fitting a model
with higher order terms. See [Westfall](https://vdoc.pub/documents/understanding-regression-analysis-a-conditional-distribution-approach-84oqjr8sqva0), 
p. 213. If we do not include the lower order terms, the coefficient does not measure what
we want it to meausure (curvature in our case). For instance, if we want to model a quadratic relationship (parabola) between
weight and height, we also have to include the linear term for weight ($x_i$).
Since we do not assume the relationship between weight and height to be linear but
quadratic (which is a polynomial of degree 2), we call this a 
[polynomial regression](https://en.wikipedia.org/wiki/Polynomial_regression#:~:text=In%20statistics%2C%20polynomial%20regression%20is,nth%20degree%20polynomial%20in%20x.).
This [video](https://www.youtube.com/watch?v=QptI-vDle8Y&ab_channel=MikeXCohen) could be instructive. 
One has to be careful with fitting polynomials to data points since the regression coefficients
can become quite large. Using a polynomial of high degree implies to have a lot of parameters 
to estimate. Increasing the degree of the polynomial increases $R^2$ but also the risk of overfitting.
(see Statistical Rethinking p. 200). So this is - of course - not the final solution to regression problems.

This time, lets look at the whole age range of data from the !Kung San people.

```{r}
library(rethinking)
library(tidyverse)
data(Howell1)
d <- Howell1
d %>% ggplot(aes(x = weight, y = height)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE, color = "blue") +
  geom_smooth(method = "loess", se = FALSE, color = "red")
```

It would not be a good idea to fit a linear trend through this data,
because we would not caupture the relationship adequately. 
The red line is a [loess smothing](https://en.wikipedia.org/wiki/Local_regression) line
which is often used to capture non-linear relationships.
The blue line is the usual line from classic linear regression (from the previous chapter).
Which one describes the data more accurately? 
In this case it is obvious, a non-linear relationship is present and it might be a good idea 
to model it. Modeling the relationship with a linear trend leads to bad residuals with structure.
We will demonstrate this in the freuqentist setting.
Unfortunately, in more complex settings, with more predictors, it is not always so easy to see.

This time, we use the mean for the prior from the book ($178 cm$).
The model equations are (see [exercise 2](#exercise2_multiple_regression)):

\begin{eqnarray*}
h_i &\sim& \text{Normal}(\mu_i, \sigma) \\
\mu_i &=& \alpha + \beta_1 x_i + \beta_2 x_i^2 \\
\alpha &\sim& \text{Normal}(178, 20) \\
\beta_1 &\sim& \text{Log-Normal}(0, 1) \\
\beta_2 &\sim& \text{Normal}(0, 1) \\
\sigma &\sim& \text{Uniform}(0, 50)
\end{eqnarray*}

The prior for $\beta_1$ is log-normal, because we can reasonably assume
the the overall linear trend is positive. 
The prior for $\beta_2$ is normal, because
we are not so sure about the sign yet. If we thought back to our school days to the topic of 
"curve discussion" or parabolas, we could probably also assume that $\beta_2$ is negative.
But, data will show.

How can we interpret the model equations? 
The model assumes that the **expected** height $\mu_i$ of a person $i$
depends non-linearly (quadratically) on the (standardized) weight $x_i$ of the person.
We are in the business of mean-modeling. 
The prior for $\sigma$ is uniform as before.
The prior for $\alpha$ is normal with mean $178$ and standard deviation $20$
because this is what we can expect from body heights in our experience.

Let's **fit the model**:

We standardize the weight again and add the squared weights to the data set.
Standardizing the predictors is a good idea, especially in polynomial regression
since squares and cubes of large numbers can get huge and cause numerical problems.

Let's fit the model with the quadratic term for weight:

```{r}
# Standardize weight
d$weight_s <- (d$weight - mean(d$weight)) / sd(d$weight)
# Square of standardized weight
d$weight_s2 <- d$weight_s^2
m4.1 <- quap(
  alist(
    height ~ dnorm(mu, sigma),
    mu <- a + b1*weight_s + b2*weight_s^2,
    a ~ dnorm(178, 20),
    b1 ~ dnorm(0, 10),
    b2 ~ dnorm(0, 10),
    sigma ~ dunif(0, 50)
  ), data = d)
precis(m4.1)
```
$\beta_2$ is indeed negative. 
We get our **[joint distribution](https://en.wikipedia.org/wiki/Joint_probability_distribution)** 
of the **four model parameters**.
Let's look at the fit using the mean estimates of the posterior distribution:

```{r}
# Summarize the model parameters
model_summary <- precis(m4.1)
params <- as.data.frame(model_summary)

# Extract parameter values
a <- params["a", "mean"]       # Intercept
b1 <- params["b1", "mean"]     # Coefficient for standardized weight
b2 <- params["b2", "mean"]     # Coefficient for squared standardized weight

# Generate a sequence of standardized weights for the fitted curve
weight_seq <- seq(min(d$weight_s), max(d$weight_s), length.out = 200)

# Calculate the fitted values using the quadratic equation
height_fitted <- a + b1 * weight_seq + b2 * weight_seq^2

# Plot the scatterplot
plot(d$weight_s, d$height, pch = 16, col = "blue",
     xlab = "Standardized Weight", ylab = "Height (cm)",
     main = "Scatterplot with Fitted Curve (Standardized Weight)")

# Add the fitted curve
lines(weight_seq, height_fitted, col = "red", lwd = 2)

# Add a legend
legend("topright", legend = c("Observed data", "Fitted curve"),
       col = c("blue", "red"), pch = c(16, NA), lty = c(NA, 1), lwd = 2)
```

This fits much better than the linear model without the quadratic term. In the book,
there is also a polynomial regression with a cubic term for weight.
Maybe this fits even better (see [exercise 1](#exercise1_multiple_regression)).

### Adding another predictor to the model {#adding_predictor_bayes}

Since the !Kung San data set has already such a high $R^2$ with the quadratic term 
(and possibly higher with the cubic term), we will use the created data set from 
[below](#adding_predictor_freq) in the frequentist setting
to estimate the coefficients of the model with two predictors.

We use rather uniformative priors and fit the model using `quap`:


```{r}
library(rethinking)
set.seed(123)
n <- 100
X1 <- rnorm(n, 0, 5)
X2 <- rnorm(n, 0, 5)
Y <- 10 + 0.5 * X1 + 1 * X2 + rnorm(n, 0, 2) # true model
df <- data.frame(X1 = X1, X2 = X2, Y = Y)

# fit model
m4.2 <- quap(
  alist(
    Y ~ dnorm(mu, sigma),
    mu <- a + b1*X1 + b2*X2,
    a ~ dnorm(10, 10),
    b1 ~ dnorm(0, 10),
    b2 ~ dnorm(0, 10),
    sigma ~ dunif(0, 50)
  ), data = df)
precis(m4.2)
```


#### Checking model assumptions {#check_model_bayes}
Andrew Gelman mentions in some of his talks (see [here](https://sites.stat.columbia.edu/gelman/research/published/philosophy_chapter.pdf) for more details) 
that many Bayesians he met do not check their models, since they reflect subjective probability.
As I said in the introduction, one should not be afraid to check model predictions against the observed
and probably new data. If a model for predicting BMI performs much worse on a new data set,
we can probably conclude that the model does not reflect the general relationship between the predictors
and the dependent variable. We **do not ask** the question if a model is true or false, but if it is useful or
how badly the model assumptions are violated.

For further, more detailed information on model checking, refer to chapter 6 of 
[Gelman's book](https://sites.stat.columbia.edu/gelman/book/BDA3.pdf).

Anyhow, we plot two posterior predictive checks here.
We test the model within the same data set. 
In order to do this, we create new observations
by drawing from the posterior distribution and compare these with the acutally 
observed values. This is called **posterior predictive checks**.

**First, we plot the observed $Y$ values against the predicted $Y$ values ($=\hat{Y}$)** 
from the model (as in Statistical rethinking, Chapter 5).
Although these practically never lie on the line $y=x$, they should be sufficiently 
close to it. We could also compare these two plots with the mean-model (see [exercise 6](#exercise6_multiple_regression)).

```{r}
# 1) Posterior predictive checks Y vs Y_hat
# see Statstical Rethinking p 138.
# call link without specifying new data
# so it uses the original data
mu <- link(m4.2)

# summarize samples accross cases
mu_mean <- apply(mu, 2, mean)
mu_PI <- apply(mu, 2, PI, prob = 0.89)

# simulate observations
# again, no new data, so uses original data
D_sim <- sim(m4.2, n = 1e4)
D_PI <- apply(D_sim, 2, PI, prob = 0.89)

plot(mu_mean ~ df$Y, col = rangi2, ylim = range(mu_PI), 
     xlab = "Observed Y", ylab = "Model-Predicted Y")
abline(a = 0, b = 1, lty = 2)
for(i in 1:nrow(df)) lines(rep(df$Y[i], 2), mu_PI[,i], col = rangi2)
```

As we can see, the model fits the data quite well. The points are close to the dashed line ($y=x$).
No under- or overestimation is visible. The model seems to capture the relationship between the predictors $X_1$ and $X_2$
and the dependent variable $Y$ quite well - at least in a predictive sense. If there were patches of data points above or below the dashed line,
we would probably have to reconsider the model definition and think about why these points are not captured by the model.

**Next, we plot the posterior predictive plots** analog to the upper left in the `check_model` output.

```{r}
library(scales)  # For the alpha function to adjust transparency

# 2) Posterior predictive densities
# Simulate observations using the posterior predictive distribution
D_sim <- sim(m4.2, n = 1e4)  # Generate 10,000 simulated datasets

# Calculate densities for all samples
densities <- apply(D_sim, 1, density)

# Find the maximum density value for setting the y-axis limits
max_density <- max(sapply(densities, function(d) max(d$y)))

# Create the density plot with predefined ylim
plot(NULL, xlim = range(df$Y), ylim = c(0, max_density),
     xlab = "Y", ylab = "Density",
     main = "Comparison of Observed and Predicted Densities")

# Add 100 posterior predictive density lines
set.seed(42)  # For reproducibility
n_lines <- 100
samples <- sample(1:1e4, n_lines)  # Randomly sample 100 posterior predictive datasets
for (s in samples) {
  lines(density(D_sim[s, ]), col = alpha("lightblue", 0.3), lwd = 1)
}

# Add the density line for the observed Y values
obs_density <- density(df$Y)
lines(obs_density$x, obs_density$y, col = "green", lwd = 2)

# Add legend
legend("topright", legend = c("Posterior Predictive Densities", "Observed Density"),
       col = c("lightblue", "green"), lty = 1, lwd = c(1, 2))
```

The light blue lines show distributions of model predicted $Y$ values. 
The green line shows the distribution of the observed $Y$ values.
As we can see, there seem to be no systematic differences between the observed and predicted values. 
The model seems to capture the relationship well.
If we see systematic deviations here, we need to reconsider the model definition. 

**Example**: If you want to predict pain ($Y$ variable) and you have a lot of zeros (pain-free participants)
you will probably see a discrepancy between the observed and predicted values in this plot.
What could you do? You could use a two step process (model the probability that a person is pain-free 
and then model the pain intensity for the people who have pain) or use a different model (like a zero-inflated model).

Note that we did not explicitely assume normally distributed errors in the model definition above,
so we won't check this here but in the Frequentist framework below.

## Linear regression with 2 predictors in the Frequentist Framework 

To reiterate from the last chapter:
In full, the **classical linear regression model** can be written as 
(see p. 21-22 in Westfall):

$$ Y_i|X_i = x_i \sim_{independent} N(\beta_0 + \beta_1 x_{i1} + \dots \beta_k x_{ik},\sigma^2)$$
for $i = 1, \dots, n$.

The $Y_i$ are independently normally distributed *conditioned* on the predictors 
having the values $X_i = x_i$. Each conditional distribution has an expected value ($\mu$)
that is a linear function of the predictors and a constant variance $\sigma^2$.

If the assumptions of the classical linear regression model are met, the least squares
estimators (OLS) are the best (smallest variance) linear unbiased (on average correct) estimators 
(so-called: BLUE) of the parameters.

### Adding a transformed predictor to the model {#adding_transformed_predictor_freq}

No, let's fit the same model as above in the Frequentist framework.

The model is:

$$height_i = \alpha + \beta_1 weight_i + \beta_2 weight_i^2 + \varepsilon_i$$
whereas
$$\varepsilon_i \sim N(0, \sigma)$$

And if you build the expectation on both sides for fixed $weight_i$, you get:

$$\mathbb{E}(height_i|weight_i) = \alpha + \beta_1 weight_i + \beta_2 weight_i^2$$

The last line means, the expected height of a person given a certain weight depends 
quadratically on the weight. The error term $\varepsilon_i$ is on average zero, hence it goes away here.
Remember the [law of large numbers](https://en.wikipedia.org/wiki/Law_of_large_numbers#Weak_law): 
The sample mean $\bar{\varepsilon_i}$ approaches the expected value $\mathbb{E}(\varepsilon_i)=0$ 
as the sample size increases. If you drew many samples and average over the error terms,
the average will approach zero.
The weights are considered fixed and therefore do not change when building the expectation.

We are looking for fixed, but unknown, parameters $\alpha$, $\beta_1$, $\beta_2$ and $\sigma$.
The fixed $\sigma$ indicates that the observations *wiggle* around the expected value
equally strong not matter which weight we have. This is called **homoscedasticity**.

Let's fit the model using the `lm` function in R which uses 
[least squares](https://en.wikipedia.org/wiki/Least_squares) to estimate the parameters.
At this point I could torture you with [matrix algebra](https://en.wikipedia.org/wiki/Matrix_(mathematics)) 
and show you the [normal equations](https://en.wikipedia.org/wiki/Linear_least_squares) for linear regression,
but I will spare you for now.
Note that the least squares algorithm for fitting the curve works for all
kinds of functional forms. For example, we could also fit an exponential curve using the same
technique (see [exercise 9](#exercise9_multiple_regression)).

```{r}
# scale weight
d$weight_s <- scale(d$weight)
# Fit the model
m4.2 <- lm(height ~ weight_s + I(weight_s^2), data = d)
summary(m4.2)
mean(d$height)
confint(m4.2, level = 0.94)
```

See `?I` in R. This command is used so that R knows that it should 
treat the "^2" as "square" and not as formula syntax.
We could also create a new variable as before. Whatever you prefer.

#### Interpretation of output and coefficients

- The intercept $\alpha$ is the **model-predicted height** of a person of **average weight** 
  ($weight_s=0$ for a person of average weight).
  Note that this is not equal to the average height ($138.2636 cm$) of the people in the data set.
- The residuals have range from $-19.97$ to $19.51$. So, the model maximally
  overestimates the heights by $19.97$ cm and underestimates by $19.51$ cm.
  These numbers are plausible when you look at the scatterplot with the fitted
  curve.
- The coefficients $\beta_1$ and $\beta_2$ agree with the Bayes estimates.
  Specifically, $\beta_2$ is non-zero indicating curvature. You cannot directly interpret the coefficients
  as in the non-quadratic case since, for instance, you cannot change $weight^2$ by one unit
  and hold $weight$ constant at the same time. Refer to Peter Westfall's book section 9.1. for all the details.
- If you like $p$-values: All the hypotheses that the coefficients are zero
  are rejected. The $p$-values are very small. The values of the test statistics can not be explained
  by chance alone. On the other hand, for at least $\beta_1$ and
  and the global test this is not a surprise when you look at the scatterplot.
  After having fit many models, you would have guessed that all three parameters 
  are solidly non-zero. The intercept is not zero since a person of average weight probably
  has non-zero height. $\beta_1$ is non-zero since you can easily imagine a linear
  trend line with positive slope going through the data, and $\beta_2$ is non-zero
  since there is clearly (non-trivial) curvature in the scatterplot.
- The $R^2$ is a whopping $0.96$ which could be a sign of overfitting, but
  in this case we conclude that the true relationship is caputured rather well.
  [Overfitting](https://en.wikipedia.org/wiki/Overfitting) would occur if 
  our curve would wiggle around the data points,
  so we would fit the data too much to the noise in the data than
  the underying trend.

#### Checking model assumptions

```{r, warnings=FALSE}
check_model(m4.2)
```

If we want to be perfectionists, we could remark that (upper right plot)
in the lower fitted values the residuals are more negative, 
meaning that the model overestimates the heights in this region.
In the middle region the model underestimates a bit and we can see
a positive tendency in the residuals. Apart from that,
the diagnostic plots look excellent.

### Adding another predictor to the model {#adding_predictor_freq}

Now, we add another predictor to the model. We use $X_1$ and $X_2$ 
**simultaneously** to predict $Y$. We are now in the lucky situation that
we can still visualize the situation in 3D. The regression line from simple
linear regression
becomes a [plane](https://stackoverflow.com/questions/47344850/scatterplot3d-regression-plane-with-residuals).
The vertical distances between the data points and the plane are the residuals.
See [here](https://rpubs.com/pjozefek/576206) or 
[here](https://www.sthda.com/english/wiki/scatterplot3d-3d-graphics-r-software-and-data-visualization)
at the end for examples.
Minimizing the sum of the squared errors gives again 
the estimates for the coefficients. 

For demonstration purposes, we can **create data ourselves** with known
coefficients. This is the same as [above](#adding_predictor_bayes).
This is the true model, which we usually do not know:

$$ Y_i = \beta_0 + \beta_1 X_{1i} + \beta_2 X_{2i} + \varepsilon_i$$
$$ \varepsilon_i \sim N(0, \sigma^2)$$
$$ \mathbb{E}(Y_i|X_1 = x_1; X_2 = x_2) = \beta_0 + \beta_1 x_1 + \beta_2 x_2$$
$$ i = 1 \ldots n$$

for example:

$$ Y_i = 10 + 0.5 \cdot X_{1i} + 1 \cdot X_{2i} + \varepsilon_i$$
$$ \varepsilon_i \sim N(0, 5)$$
$$ \mathbb{E}(Y_i|X_1 = x_1; X_2 = x_2) = 10 + 0.5 x_1 + 1 x_2$$
$$ i = 1 \ldots n$$


According to the model, the conditional expected value of $Y_i$ given $X_1 = x_1$ and $X_2 = x_2$
is a linear function of $x_1$ and $x_2$. Note, that small letters are realized values
of random variables. Also note, that in the expectation the error term goes away, since
$\mathbb{E}(\varepsilon_i) = 0$.

- If $X_1$ increases by one unit, $Y$ increases by $0.5$ units on average (in expectation).
- If $X_2$ increases by one unit, $Y$ increases by $1$ unit on average (in expectation).
- If $X_1$ and $X_2$ are zero, $Y$ is $10$ on average (in expectation).

Why in expectation? Because there is still the error term which makes the whole thing random!
We can see that an increase in $X_1$ does not influence the relationship between $X_2$ and $Y$.
Hence, there is **no interaction** between $X_1$ and $X_2$ with respect to $Y$.

Now lets's draw 100 points from this model, fit the model and add the plane:

```{r}
library(plotly)

set.seed(123)
n <- 100
X1 <- rnorm(n, 0, 5)
X2 <- rnorm(n, 0, 5)
Y <- 10 + 0.5 * X1 + 1 * X2 + rnorm(n, 0, 2)
d <- data.frame(X1 = X1, X2 = X2, Y = Y)

# Fit the model
m4.3 <- lm(Y ~ X1 + X2, data = d)
summary(m4.3)

# Create a grid for the plane
X1_grid <- seq(min(d$X1), max(d$X1), length.out = 20)
X2_grid <- seq(min(d$X2), max(d$X2), length.out = 20)
grid <- expand.grid(X1 = X1_grid, X2 = X2_grid)

# Predict the values for the grid
grid$Y <- predict(m4.3, newdata = grid)

# Convert the grid into a matrix for the plane
plane_matrix <- matrix(grid$Y, nrow = length(X1_grid), ncol = length(X2_grid))

# Create the interactive 3D plot
plot_ly() %>%
  add_markers(
    x = d$X2, y = d$X1, z = d$Y,
    marker = list(color = "blue", size = 5),
    name = "Data Points"
  ) %>%
  add_surface(
    x = X1_grid, y = X2_grid, z = plane_matrix,
    colorscale = list(c(0, 1), c("red", "pink")),
    showscale = FALSE,
    opacity = 0.7,
    name = "Fitted Plane"
  ) %>%
  plotly::layout(
    scene = list(
      xaxis = list(title = "X1"),
      yaxis = list(title = "X2"),
      zaxis = list(title = "Y")
    ),
    title = "Interactive 3D Scatterplot with Fitted Plane"
  )
```

This is, of course, a very idealized situation. There is no curvature in the plane,
no interaction, no outliers, no heteroscadasticity. It's the simplest case of multiple regression
with 2 predictors. Reality is - usually - more complicated.

Let's look at summary output and check model assumptions:

```{r}
summary(m4.3)
check_model(m4.3)
```

We could repeat this simulation to get a feeling for the variability.
The posterior predictive checks look nice. In this case, we *know* that the model is true
and with this knowledge we can assess the diagnostic plots in front of us.

#### Adding variables to the model and why

This is a very complex question. We will go into it in later chapters and the next course (Methodenvertiefung).
At this point we can say this:
Depending on the goal at hand (prediction or explanation), we add variables to the model and probably use 
other models apart from linear regression.
Prediction seems to be easier than explanation. For instance, within linear models and 
just a handful of predictors, one can even brute force the problem by searching through
all subsets of predictors. If that is not possible, one could use clever algortithms, like 
[best subest selection](https://www.sthda.com/english/articles/37-model-selection-essentials-in-r/155-best-subsets-regression-essentials-in-r/). 

- What is **not** a good idea is to throw all variables into the model and hope for the best.
- What is also not a good idea is to select variables depending on the $p$-values of the coefficients.
- **Leaving variables out**, that are important, can lead to biased estimates of the coefficients 
  ([omitted variable bias](https://en.wikipedia.org/wiki/Omitted-variable_bias)).
- Importantly, also **adding variables** can hurt conclusions from the model (see Statistical Rethinking 6.2).


### Interaction Term $X_1 \times X_2$ {#interaction_term}

I recommend reading the excellent explanations about interactions
in John Kruschke's book [Doing Bayesian Data Analysis](https://nyu-cdsc.github.io/learningr/assets/kruschke_bayesian_in_R.pdf),
15.2.2 und 15.2.3. Peter Westfall also has a nice explanation in his [book](https://www.routledge.com/Understanding-Regression-Analysis-A-Conditional-Distribution-Approach/Westfall-Arias/p/book/9780367493516?srsltid=AfmBOore3O_Ciecl0TTkr9AjPIY1d6OmbQa7o7IAdKpTSkD8s9HkwzD4) 
in section 9.3.

Our statistical model is now:

$$ Y_i = \beta_0 + \beta_1 X_{1i} + \beta_2 X_{2i} + \mathbf{\beta_3 X_{1i} \times X_{2i}} + \varepsilon_i$$
$$ \varepsilon_i \sim N(0, \sigma^2)$$
$$ \mathbb{E}(Y_i|X_1 = x_1; X_2 = x_2) = \beta_0 + \beta_1 x_{1} + \beta_2 x_{2} + \beta_3 x_{1} \times x_{2}$$
$$ i = 1 \ldots n$$

for example:

$$ Y_i = 10 + 0.5 \cdot X_{1i} + 1 \cdot X_{2i} + 0.89 \cdot X_{1i} \times X_{2i} + \varepsilon_i$$
$$ \varepsilon_i \sim N(0, 5)$$
$$ \mathbb{E}(Y_i|X_1 = x_1; X_2 = x_2) = 10 + 0.5 x_1 + 1 x_2 + 0.89 x_1 \times x_2$$
$$ i = 1 \ldots n$$

The second equation states that the conditional expectation of $Y_i$ given $X_1=x_1$ and $X_2=x_2$ 
is a function of $x_1$ and $x_2$ and their interaction $x_1 \times x_2$. We are in a different situation now.
Set for instance $x_2$ to a certain value, say $x_2 = 7$. Then the relationship (in expectation) 
between $Y$ and $X_1$ is:

$$ \mathbb{E}(Y_i|X_1 = x_1; X_2 = 7) = 10 + 0.5 x_1 + 1 \cdot 7 + 0.89 x_1 \cdot 7$$
$$ \mathbb{E}(Y_i|X_1 = x_1; X_2 = 7) = 10 + (0.5 + 0.89 \cdot \mathbf{7}) \cdot x_1 + 1 \cdot 7$$

Depending on the value of $x_2$, the *effect* of $X_1$ on $Y$ changes. 
Hence, $X_2$ **modifies** the relationship between $X_1$ and $Y$, or stated otherwise,
$X_1$ and $X_2$ **interact** with respect to $Y$. Remember, the word *effect* is 
used in a strictly technical/statistical sense and **not in a causal** sense.
It does not mean that if we *do* change $X_1$ by one unit, 
$Y$ will also change in an experiment. We are purely describing the relationship
in an associative way. We will probably touch causality in a later chapter.
Bayesian statistics and causal inference are gaining popularity. Hence, we should try to keep up.

Let's draw 100 points from this model, fit the model and add the plane (see also [exercise 4](#exercise3_multiple_regression)):

```{r}
set.seed(123)
n <- 100
X1 <- rnorm(n, 0, 5)
X2 <- rnorm(n, 0, 5)
Y <- 10 + 0.5 * X1 + 1 * X2 + 0.89 * X1 * X2 + rnorm(n, 0, 5)
d <- data.frame(X1 = X1, X2 = X2, Y = Y)

# Fit the model
m4.4 <- lm(Y ~ X1 * X2, data = d)
summary(m4.4)

# Create a grid for the plane
X1_grid <- seq(min(d$X1), max(d$X1), length.out = 20)
X2_grid <- seq(min(d$X2), max(d$X2), length.out = 20)
grid <- expand.grid(X1 = X1_grid, X2 = X2_grid)

# Predict the values for the grid
grid$Y <- predict(m4.4, newdata = grid)

# Convert the grid into a matrix for the plane
plane_matrix <- matrix(grid$Y, nrow = length(X1_grid), ncol = length(X2_grid))

# Create the interactive 3D plot
plot_ly() %>%
  add_markers(
    x = d$X2, y = d$X1, z = d$Y,
    marker = list(color = "blue", size = 5),
    name = "Data Points"
  ) %>%
  add_surface(
    x = X1_grid, y = X2_grid, z = plane_matrix,
    colorscale = list(c(0, 1), c("red", "pink")),
    showscale = FALSE,
    opacity = 0.7,
    name = "Fitted Plane"
  ) %>%
  plotly::layout(
    scene = list(
      xaxis = list(title = "X1"),
      yaxis = list(title = "X2"),
      zaxis = list(title = "Y")
    ),
    title = "Interactive 3D Scatterplot with Fitted Plane"
  )
```

The term `X1 * X2` is a shortcut for `X1 + X2 + X1:X2` where `X1:X2` is the interaction term.
R automatically includes the main effects of the predictors when an interaction term is included.
The true but usually unknown $\beta$s are estimated quite precisely.

#### Formal test for interaction
We could apply a formal test for the interaction term by model comparison.
The command `anova(., .)` would compare the two models and test if the change in the
residual sum of squares is statistically interesting.

```{r}
m4.5 <- lm(Y ~ X1 + X2, data = d) # without interaction
anova(m4.5, m4.4)
```

One can show that the following test statistic is $F$ distributed under the null hypothesis:

$$ F = \frac{\left(RSS_{\text{Model 1}} - RSS_{\text{Model 2}}\right) / \left(df_{\text{Model 1}} - df_{\text{Model 2}}\right)}{RSS_{\text{Model 2}} / df_{\text{Model 2}}}$$

where $RSS$ is the residual sum of squares, 
$df$ are the degrees of freedom of the residual sum of squares for both models.

The output of the `anova` command shows us the residual degress of freedom (`Res.Df`)
of both models, the residual sum of squares errors of both models (`RSS`), 
the sum of squared errors between model 1 and model 2 (`Sum of Sq`), the value of the 
F-statistic and the $p$-value for the hypothesis, that the coefficient for
the interaction term is zero ($\beta_3=0$). Model 1 RSS has 97 degrees of freedom, since we have 100 data points
and 3 parameters to estimate ($\beta_0, \beta_1, \beta_2$). Model 2 has 96 degrees of freedom, since
we have 100 data points and 4 parameters to estimate ($\beta_0, \beta_1, \beta_2, \beta_3$).

Let's verify the value of the $F$ statistic:

```{r}
RSS_model1 <- sum(residuals(m4.5)^2)
RSS_model2 <- sum(residuals(m4.4)^2)
df_model1 <- n - length(coef(m4.5))
df_model2 <- n - length(coef(m4.4))
F <- ((RSS_model1 - RSS_model2) / (df_model1 - df_model2)) / (RSS_model2 / df_model2)
F
# Sum of Sq
RSS_model1 - RSS_model2
```

In the numerator of the $F$ statistic, we have the change in the residual sum of squares 
(from the small (model 1) model to the larger one (model 2), `Sum of Sq`)
per additional parameter in the model (one additional parameter $\beta_3$). 

In the denominator, we have the residual sum of squares per residual degree of freedom of 
the larger model (model 2). Hence, in the numerator we have the information on how much
better we get with respect to the number of variables added, and in the denominator
we have information on how good the full model is with respect to its degrees of freedom.

The $p$-value is the probability of observing a value of the F statistic as extreme or more 
extreme than the one we observed, given that the null hypothesis is true. Here, 
the $p$-value is extremely small. So, statistically we would see an improvement in RSS
which is not explainable by chance alone.
But **let's be careful with $p$-values** and especially with fixed cutoff values for $\alpha$, 
which we will **never** use in this script.
Even for a rather small effect $\beta_3$, we would reject the null hypothesis, if only the sample
size is large enough. Since a very small effect relative to $\beta_1$ and $\beta_2$ would
probably not be of practical interest, one should be careful with looking at $p$-values alone.
For instance, in Richard McElreath's book [Statistical Rethinking](https://xcelab.net/rm/statistical-rethinking/),
there are no $p$-values at all. I like that.

If you again look at the comparison of the RSS between the two models, you would 
immediately see that the model with the interaction term is better (at least with respect to this metric). 
The difference is huge. We have already mentioned in the context of $R^2$ not to overinterpret 
such metric, because RSS is monotonically descreasing with number of variables added and reaches
zero when the number of variables equals the number of data points (see [exercise 3](#exercise3_multiple_regression)).

### Using an interaction plot to see a potential interaction {#interaction_plot}

Chronologically before we include an interaction term in the model, we can use an interaction plot
to see if there is a potential interaction between the predictors.
We can just create a catorical predictor out of the continuous predictors.
We just categorize the predictors into quartiles and plot the means of the dependent variable ($Y$).
If the lines are parallel, there is no interaction. If the lines are not parallel, 
there might be an interaction.

```{r}
n <- 100
X1 <- rnorm(n, 0, 5)
X2 <- rnorm(n, 0, 5)
Y <- 10 + 0.5 * X1 + 1 * X2 + 0.89 * X1 * X2 + rnorm(n, 0, 5)
d <- data.frame(X1 = X1, X2 = X2, Y = Y)

# Create categorical variables based on quartiles
d$X2_cat <- cut(d$X2, 
                breaks = quantile(d$X2, probs = c(0, 0.25, 0.5, 0.75, 1), na.rm = TRUE), 
                include.lowest = TRUE, 
                labels = c("Q1", "Q2", "Q3", "Q4"))

d$X1_cat <- cut(d$X1, 
                breaks = quantile(d$X1, probs = c(0, 0.25, 0.5, 0.75, 1), na.rm = TRUE), 
                include.lowest = TRUE, 
                labels = c("Q1", "Q2", "Q3", "Q4"))

# Create the interaction plot
interaction.plot(d$X2_cat, d$X1_cat, d$Y)
```

There seems to be an intercation of the predictors with respect to $Y$. The lines are not parallel.
If there was no interaction, the change in $Y$ with respect to $X_2$ would be the same 
for all levels of $X_1$.
This seems not to be the case here.
See [exercise 5](#exercise5_multiple_regression).

If we had one or both predictors already categorical, we would not have to discretize them before.

### Simpsons Paradox {#simpsons_paradox}

The [Simpsons paradox](https://en.wikipedia.org/wiki/Simpson%27s_paradox) is a phenomenon, 
in which a trend appears in several different groups of data but disappears 
or reverses when these groups are combined. I agree with the criticism that this is not really 
a paradox but a failure to consider confounding variables adequately. Let's quickly invent an example.
We are interested in the relationship hours of muscle training and strength (not based on evidence)
in children vs. adults. Within both groups there will be an increasing relationship. The more training,
the more muscle strength. But if we combine the groups, we will see a decreasing relationship.

```{r}
library(tidyverse)
n <- 100
age <- c(rep("child", n/2), rep("adult", n/2))
training <- c(rnorm(n/2, 0, 5) + 30, rnorm(n/2, 0, 5)+ 10)
strength <- c(
  10 + 0.5 * training[1:(n/2)] + rnorm(n/2, 0, 2), # For children
  25 + 0.5 * training[(n/2 + 1):n] + rnorm(n/2, 0, 2) # For adults
)

d <- data.frame(age = age, training = training, strength = strength)

ggplot(d, aes(x = training, y = strength, color = age)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE) + # Group-specific regression lines
  geom_smooth(data = d, aes(x = training, y = strength), 
              method = "lm", se = FALSE, color = "black", linetype = "dashed", linewidth = 1.2) + # Overall regression line
  labs(title = "Regression Lines for Training and Strength",
       x = "Training",
       y = "Strength") +
  theme_minimal() + 
  theme(plot.title = element_text(hjust = 0.5))
```

- **Group-Specific Trends**:
   - In the group of **children** (blue line), strength **increases** with training, as indicated by the positive slope of the regression line.
   - Similarly, in the group of **adults** (red line), strength also **increases** with training.

- **Overall Trend**:
   - When both groups are combined, the overall regression line (black, dashed) shows a **negative slope**, suggesting that **strength decreases** with training. 
   - This overall trend is opposite to the trends observed within the individual groups.

- **Why Does This Happen?**
   - This paradox occurs because the relationship between the grouping variable (`age`) and the independent variable (`training`) creates a confounding effect.
   - In this case: Children tend to have higher training values overall, 
     while adults tend to have lower training values.

This (fictitious) example shows that throwing variables into a multiple regression 
model without thinking about it, is not a good idea.

## What happens when you just throw variables into multiple regression? {#throwing_variables}

This sub-chapter is **important**. I can guarantee you that not too many applied 
scientists using regression models know about this.

A first taste of causality.

Richard McElreath has 3 cool examples on 
[github](https://github.com/rmcelreath/causal_salad_2021/blob/main/1_causal_salad.r)
that show what happens if you include variables the wrong way and explains this in a 
[video](https://www.youtube.com/watch?v=KNPYUVmY3NM&ab_channel=RichardMcElreath).

We will look at these below - **the pipe, the fork and the collider**. These are causal graphs showing the 
relationships between the variables. One is interested in the **effect** of X on Y.
In this case, it is truly an *effect*, since we create the models in such a way that changing
one variable, changes the other - which is indicated by an arrow in the graph.
These graphs are called DAGs - directed acyclic graphs. *Directed* because of the arrows,
*acyclic* because there are no cycles in the graph. One nice tool for drawing them is
[dagitty](https://www.dagitty.net/), which is also [implemented in R](https://cran.r-project.org/web/packages/dagitty/index.html).

### Pipe
In this setting $X$ is associated with $Z$ and $Z$ is associated with $Y$. 
$X$ and $Y$ are not directly associated, but through $Z$ (see graph below).
If we condition on $Z$, the association between $X$ and $Y$ *disappears*.
This means, if we **know** the value of $Z$, $X$ does not give us any *additional* information about $Y$.

This can be seen in the scatterplot: Once we are within $Z=0$ (black dots) or $Z=1$ (red dots), 
$X$ does not give us any information about $Y$,
i.e., the point cloud is horizontal and there is no correlation.

The `inv_logit` function is the inverse of the logit function.
It assigns higher probability of $Z$ being $1$ if X has a higher value.
Let's plot this for understanding:

```{r}
x <- seq(-3, 3, 0.1)
plot(x, inv_logit(x), type = "l", col = "blue", lwd = 2, xlab = "X", ylab = "P(Z=1|X)")
```

Higher $X$ values lead to higher probabilities of $Z=1$. 
As you can see, more red dots are on the right side of the scatterplot below.

Now to the pipe and a mini simulation for it:

```{r}
# pipe
library(dagitty)
library(tidyverse)
library(ggdag)

dag <- dagitty( 'dag {
  X -> Z -> Y
}' )

dagitty::coordinates( dag ) <-
  list( x=c(X=0, Y=2, Z=1),
        y=c(X=0, Y=0, Z=0) )

ggdag(dag) + 
  theme_dag()

# d-separation plots
a <- 0.7
cols <- c( col.alpha(1,a) , col.alpha(2,a) )

# pipe
# X -> Z -> Y
N <- 1000
X <- rnorm(N)
Z <- rbern(N,inv_logit(X))
Y <- rnorm(N,(2*Z-1))

plot( X , Y , col=cols[Z+1] , pch=16 )
abline(lm(Y[Z==1]~X[Z==1]),col=2,lwd=3)
abline(lm(Y[Z==0]~X[Z==0]),col=1,lwd=3)
abline(lm(Y~X),lwd=3,lty=3)

cor(X[Z==1],Y[Z==1])
cor(X[Z==0],Y[Z==0])
```

Or in the framework of Simpsons paradox:

```{r}
library(rethinking)

N <- 1000
X <- rnorm(N)
Z <- rbern(N,inv_logit(X))
Y <- rnorm(N,(2*Z-1))
mod1 <- lm(Y ~ X) # without conditioning on Z
summary(mod1)
mod2 <- lm(Y ~ X + Z) # with conditioning on Z
summary(mod2)
```

Adding $Z$ to the model (i.e., conditioning on $Z$) makes the coefficient for $X$ disappear. 
Knowing $Z$ means that $X$ does not give us any additional information about $Y$.
See [exercise 7](#exercise7_multiple_regression).

$Z$ is also called a [**mediator**](https://en.wikipedia.org/wiki/Mediation_(statistics)).

We could easily verify that $Z$ constitutes a mediator by using Baron and 
Kenny's 1986 approach (see Wiki):

```{r}
summary(lm(Y ~ X))# Step 1
summary(lm(Z ~ X))# Step 2
summary(lm(Y ~ X + Z))# Step 3
```

Both coefficients for $X$ are "significant" in steps 1 and 2.
The coefficients for $Z$ in step 3 is "significant" and the coefficient for
$X$ is smaller compared to step 1. And not to forget: the very small $p$-values are strongly
related to the very large smaple size and a strict cutoff ($\alpha = 0.05$) makes no sense.


### Fork

In health science, this is the classical [confounder](https://en.wikipedia.org/wiki/Confounding).
$Z$ is associated with $X$ and $Y$. $X$ and $Y$ are *actually* not associated (no arrow) but an association is 
still shown: `cor(X,Y) = 0.5097437`. 
But if we condition on $Z$, the association between $X$ and $Y$ disappears. The assocation is 
spurious in this case and *adjusting* for the confounder yields the correct result. 

```{r}
# fork
# X <- Z -> Y

dag <- dagitty( 'dag {
  X <- Z -> Y
}' )

dagitty::coordinates( dag ) <-
  list( x=c(X=0, Y=2, Z=1),
        y=c(X=0.5, Y=0.5, Z=0) )

ggdag(dag) + theme_dag()

N <- 1000
Z <- rbern(N)
X <- rnorm(N,2*Z-1)
Y <- rnorm(N,(2*Z-1))

plot( X , Y , col=cols[Z+1] , pch=16 )
abline(lm(Y[Z==1]~X[Z==1]),col=2,lwd=3)
abline(lm(Y[Z==0]~X[Z==0]),col=1,lwd=3)
abline(lm(Y~X),lwd=3,lty=3)

cor(X[Z==1],Y[Z==1])
cor(X[Z==0],Y[Z==0])
cor(X,Y)
```

In the example, we know that $Z$ is associated with both $X$ and $Y$ (per construction).
As you can see in the definitions of $X$, $Y$ and $Z$, $X$ and $Y$ would not be associated 
weren't it for $Z$. 



### Collider {#collider}
This is rather interesting. $X$ and $Y$ are independently associated 
with $Z$. This can be seen in the toy example below, where $X$ and $Y$ are used
for the definition of $Z$. $Z$ is defined as a **sum 
score** of $X$ and $Y$. Sum scores are *very* often used in health sciences (and others).
The higher the sum score, the higher the probability that $Z=1$.
Now, *if* we know the value of $Z$, $X$ and $Y$ are negatively associated (see graph). 
The reason for this association is that there is a compensatory effect. In order to get a high 
score, you can either have a high value of $X$ or $Y$ or both.
This induces the negative correlation.

```{r}
# collider
# X -> Z <- Y

#dag
dag <- dagitty( 'dag {
  X -> Z <- Y
}' )

dagitty::coordinates( dag ) <-
  list( x=c(X=0, Y=2, Z=1),
        y=c(X=0, Y=0, Z=1) )

ggdag(dag) + theme_dag()

N <- 1000
X <- rnorm(N)
Y <- rnorm(N)
Z <- rbern(N,inv_logit(2*X+2*Y-2))

plot( X , Y , col=cols[Z+1] , pch=16 )
abline(lm(Y[Z==1]~X[Z==1]),col=2,lwd=3)
abline(lm(Y[Z==0]~X[Z==0]),col=1,lwd=3)
abline(lm(Y~X),lwd=3,lty=3)

cor(Y[Z==1], X[Z==1])
cor(Y[Z==0], X[Z==0])

summary(lm(Y ~ X)) # mod1
summary(lm(Y ~ X + Z)) # mod2
```

If you think of Simpsons paradox again, conditioning on $Z$ *creates* an association between $X$ and $Y$,
which would otherwise be independent (by definition). So by learning the value of $Z$, we can learn something
from $X$ about $Y$. On the one hand, adding $Z$ to the model creates an association where there is none,
on the other hand, *prediction* of $Y$ is better with $Z$ in the model! In prediction, we largely
do not care about the causal structure of the data. We just want to predict $Y$ as accurately as possible.

The sum score example is also called [Berkson's paradox](https://en.wikipedia.org/wiki/Berkson%27s_paradox).
Let's check if this also works for three variables in a sum score 
in [exercise 10](#exercise10_multiple_regression).

### Multicollinearity {#multicollinearity}
Westfall section 8.4 and McElreath section 6.1 cover this topic.
[Multicollinearity](https://en.wikipedia.org/wiki/Multicollinearity) means that there is a strong
correlation between two or more predictors. *Perfect* multicollinearity it is when the correlation is 1.
For example, if you accidentally include the same variable twice in the model, or when you include
the elements of a sum score and the sum score itself as predictors in the model. R just gives you 
an *NA* if you do this in `lm`. 

#### Example from McElreath 6.1 {#mcElreath_6.1}
The code creates body heights and leg lengths (left and right) for 100 people.

`runif` draws a uniform random number between 40 and 50% of height as leg length, hence on average 45%.
The slope in the linear regression should therefore be around the average height divided by the average leg length:
$\frac{10}{0.45 \cdot 10} \sim 2.2$.

```{r}
library(rethinking)

N <- 100
set.seed(909)
height <- rnorm(N, 10, 2)
leg_prop <- runif(N, 0.4, 0.5)
leg_left <- leg_prop * height + rnorm(N, 0, 0.02)
leg_right <- leg_prop * height + rnorm(N, 0, 0.02)

d <- data.frame(height = height, leg_left = leg_left, leg_right = leg_right)
cor(d$leg_left, d$leg_right)

m4.6 <- quap(
  alist(
    height ~ dnorm(mu, sigma),
    mu <- a + bl * leg_left + br * leg_right,
    a ~ dnorm(10, 100),
    bl ~ dnorm(2, 10),
    br ~ dnorm(2, 10),
    sigma ~ dexp(1)
  ),    data = d
)
precis(m4.6)
plot(precis(m4.6))
```

With the given regression model, one asks the question: "What is the value of knowing each leg's length, after 
already knowing the other leg's length?" The answer is: "Not much.", since they are highly correlated.
Both coefficients are not around the expected $\beta$ and the credible intervals are wide and include the 
credible value $0$.

```{r}
post <- extract.samples(m4.6)
plot( bl ~ br, post, col=col.alpha(rangi2,0.1), pch = 16 )
```

Since the two coefficients are almost perfectly multicollinear 
(`cor(d$leg_left, d$leg_right)=0.9997458`), knowing one leg's length does not 
give us any additional information about the other leg's length.
Leaving out the right leg length would give the correct result ([exercise 11](#exercise11_multiple_regression)).


#### Example from Westfall 8.4

In the example below, the second prector $X2$ is a perfect linear function of the first predictor $X1$.

```{r}
# Westfall 8.4.
set.seed(12345)
X1 = rnorm(100)
X2 = 2*X1 -1     # Perfect collinearity
Y = 1 + 2*X1 + 3*X2 + rnorm(100,0,1)
summary(lm(Y~X1+X2))
```

Let's look at a 3D plot:

```{r}
library(plotly)

# Generate data
set.seed(42)
X1 <- rnorm(100)
X2 <- 2 * X1 - 1  # Perfect collinearity
Y  <- 1 + 2 * X1 + 3 * X2 + rnorm(100, 0, 1)

# Create the 3D scatter plot with vertical lines
plot_ly() %>%
  add_markers(x = X1, y = X2, z = Y, 
              marker = list(color = Y, colorscale = "Viridis", size = 5),
              name = "Data Points") %>%
  layout(title = "3D Scatter Plot",
         scene = list(xaxis = list(title = "X1"),
                      yaxis = list(title = "X2"),
                      zaxis = list(title = "Y")))
#VIF(lm(Y ~ X1 + X2)) # error
#check_model(lm(Y ~ X1 + X2)) # error
```


There is no unique solution for a plane in this case.
Infinitely many planes can be defined using the "line" in space.
If anything, a perfectly vertical plane could go through with $SSE = 0$,
but such a plane would not tell us how $Y$ changes with $X1$ and $X2$,
since any $Y$ value could be assigned to any credible combination of $X1$ and $X2$ values.
The problem collapses into the simple linear regression problem.
One could just plug in the formula for $X2$ into the model, which yields the identical result:

```{r}
set.seed(12345)
X1 = rnorm(100)
# Y = 1 + 2*X1 + 3*(2*X1 -1) + rnorm(100,0,1) = 
Y = -2 + 8*X1 + rnorm(100,0,1)
summary(lm(Y ~ X1))
```

In reality, you only have one parameter ($X1$ or $X2$) in the case of perfect multicollinearity.

## More than 2 predictors
.........




## Exercises

[E] Easy, [M] Medium, [H] Hard

(Some) solutions to exercises can be found in the git-repo [here](https://github.com/jdegenfellner/Script_QM2_ZHAW/tree/main/Solutions_Exercises).

### [M] Exercise 1 {#exercise1_multiple_regression}

- Fit a model with a cubic term for weight and height of the !Kung San people.
- Add the prediction bands as seen in the book.
- Come up with an explanation for the functional form of this relationship.
- Could there be reasons to for taking a less complicated model 
  ([1](https://en.wikipedia.org/wiki/Statistical_model_specification), [2](https://en.wikipedia.org/wiki/Occam%27s_razor))?

### [E] Exercise 2 {#exercise2_multiple_regression}

Consider the model equations from [above](#adding_transformed_predictor) 
where we used polynomial regression to model the relationship between 
weight and height:

- Draw the model hierarchy for the model.

### [H] Exercise 3 {#exercise3_multiple_regression}

Invent a data set (or use the first 3 lines of a previous data set) 
with 3 observations of $Y$ and $X_1, X_2$ and $X_3$. You have a data frame
with 3 rows and 4 columns. 

- Fit a model with $Y$ as the dependent variable and $X_1, X_2, X_3$ as predictors.
- How big is $R^2$?
- Could you have calulated this without `lm`and R?

### [E] Exercise 4 {#exercise4_multiple_regression}

Go back to the [section about the interaction term](#interaction_term) in the linear model.

- Use the code provided.
- Standardise the predictors. How are the $\beta$s changing and what is their interpration now?
- Change the relative sizes of the true but usually unknown $\beta$s. 
  What happens to the estimates and the graph?
- What happens if you change the error term and increase or decrease its variance?

### [E] Exercise 5 {#exercise5_multiple_regression}

Draw the interaction plot from the [section about the interaction plot](#interaction_plot) 
for the case when there is no interaction, i.e. $\beta_3 = 0$.

### [M] Exercise 6 {#exercise6_multiple_regression}

Go back to the model assumptions checks [above](#check_model_bayes).

- Create the same two plots for the simple mean model without predictors, just with the intercept.
- Which model fits the data better according to these posterior predictive checks?

### [E] Exercise 7 {#exercise7_multiple_regression}

Go back to the Simpson's paradox [section](#simpsons_paradox).

- Invent your own example for the pipe, fork and collider.

### [M] Exercise 8 {#exercise8_multiple_regression}

- Take a data set of your choosing with many columns, say 10 or so, either from the internet 
  or from R (if available)
- Fit a model for an arbitrary outcome, add more and more variables to predict the outcome
  and verify that the $R^2$ increases.

### [M] Exercise 9 {#exercise9_multiple_regression}

Exponential curve fitting. Go back to the [section](#adding_transformed_predictor_freq) about adding a transformed predictor in the Frequentist
setting. Hint: You can use the `optim` function in R.

- Assume the relationship between weight and height looks like this: 
  $height_i = \alpha + \beta_1 e^{\beta_2 weight_i}$.
- Use R and the least squares method to estimate the parameters $\alpha, \beta_1, \beta_2$.
- Note that the sum of squared errors is this: 
  $\sum_{i=1}^n (height_i - \alpha - \beta_1 e^{\beta_2 weight_i})^2$.
- What happens if you do not constrain the parameters $\beta_1$ and $\beta_2$ to be negative?
- Calculate the $R^2$ for this model.

### [E] Exercise 10 {#exercise10_multiple_regression}

Let's try to verify if Berkson's paradox (which we have mentioned in the 
[collider-section](#collider)) also works for three variables in a sum score.

- Now, we assume some college admits only applicants in the top 20% of a score 
  consisting of the sum of three variables: $W, X, Z$ (grade point average, math score, verbal score).
- All three scores are individually normally distributed with mean 100 and standard deviation 15.
- Calculate the correlation matrix `cor()` of all students and the admitted students.
- Are any of the three variables correlated?
- Plot a scatterplot of the math score and the verbal score und color the points according 
  to being admitted or not. You can add trendlines for the two groups.

### [E] Exercise 11 {#exercise11_multiple_regression}

Go back to the multicollinearity [section](#multicollinearity) and the [example](#mcElreath_6.1) 
from McElreath 6.1.

- Verify that the coefficient is correct when leaving out the right leg length from the model.



## TODOS

- `check_model` for 2 and more predictors...
- Factors, caterical variables in model...
- Violations of model assumptions and how to fix them.
- Add more Bayesian model checks, chapter 6 Gelman.
- Show by simulation what Gelman talks about with significant p values. So I scan the data
  for significant p values and then simulate data with the same effect size and see how often
  I get significant p values. Especially the next effect would be probably smaller,
  especially, if one did p-hacking! Calculate a priori probability for replication (def?).
- Variability of confidence interval borders (draw from X...)
- Logistic Regression, Poisson, ...
- Chapter: Sample size calculations for logistic and multivariate regression, Proportions, ICCs, t.test
- Chapter about Reliability, Validity and ICCs (incl. simulation of what an ICC of 0.9 or so means), but maybe reduced
- causal terror of richards book, fork, pipe, collider
- Angenommen man hat ein masking eines Effekts und der Model fit ist aber gut (keine Voraussetzung verletzt), 
  ist diese Situation möglich?
- What about 2 interactions?
- Which variables should I include in a model and why?
- What about a real life data set?
- What about papers?
- Simulate a cohort of Master thesis with small sample sizes and assume 
  that there is a true but unknown effect.
- AIC, BIC, cross-validation, Model selection (best subset, leaps....), Variable selection
- More on bias variance tradeoff, show for polynomial regression?
- include eLearning tasks in script.
